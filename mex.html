<!DOCTYPE html>
<meta charset="utf-8">
<head>
     <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">

<title>Mexico Topojson</title>

<style>
.graticule { fill: none; stroke: #000; stroke-opacity: .3; stroke-width: .5px; }

.graticule.outline { stroke: #333; stroke-opacity: 1; stroke-width: 1.5px; }

.axis path { fill: none; stroke-width: 1px; stroke: #000; }
.axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
.line_base { fill: none; stroke: rgb(230, 127, 51); }
.line_vac { fill: none; stroke: rgb(51, 127, 204); }
.text_base { font-size:150%; font-weight:bold; color: rgb(230, 127, 51); }
.text_vac  { font-size:150%; font-weight:bold; color: rgb(51, 127, 204); }
</style>
</head>

<body>

<script src="http://d3js.org/d3.v3.js"></script>
<script src="http://d3js.org/topojson.v0.js"></script>
<script src="http://d3js.org/d3.geo.projection.v0.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>

<nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand" href="#">Dengue Sim Visualization</a>
                <div class='form-inline'>
               <button id='startStopButton' class="btn btn-success" onClick="runSimulation()">Start/Stop</button> 
                <button  id='restart' class="btn btn-primary" onClick="restartSimulation()">Restart</button> 
                </div>
        </div>
    </div>
</nav>


<div class="container">
    <div class="col-md-12 form-inline"> 
            <div class='form-group'>
                <div class='row'>
                <label> Starting day:  </label>
                <input class='input-sm' type="number" id="startingDayBox" class="form-control"  value="0" min="1" max="365" onChange="changeStartDay()"> 
                <label>  Time step:  </label>
                <input class='input-sm' type="number" id="timeStepBox" class="form-control"  value="14" min="1" max="365" size="2" onChange="changeTimeStep()"> 
                <label> Data set: </label>
                <select id=dataSetMenu onChange="changeDataSet()" class="form-control" >
                <option value="mfoi">   Medium FOI  </option> 
                <option value="hfoi" selected='selected'>   High FOI  </option> 
                <!-- <option value="empty" selected='selected'>   Empty  </option> -->
                </select>
           </div>
      </div>
</div>
 
<div class='container'>
  <div class="col-md-12"> 
    <span id='curDayDiv'> &nbsp </span>
    <div id='tsPlotDiv'> </div>
  </div>
</div>

<div class='container'>

  <div class="col-md-12"> 
    <span class='col-md-6 text-center text_base'> Baseline </span>
    <span class='col-md-6 text-center text_vac'> 14 routine + 15-46 catch-up </span>
  </div>

  <div class="col-md-12"> 
    <div class="col-md-6" id='svgMapDiv1'> </div>
    <div class="col-md-6" id='svgMapDiv2'> </div>
  </div>

</div>

<script>


var width             = 1000;
var mapwidth          = 500;
var height            = 500;
var timeStep          = changeTimeStep(); // Update polygons this often
var dataSetFilename   = changeDataSet();
var startDay          = 0;
var tsPlotDivHeight   = 150;

var svgMapElement1 = d3.select("#svgMapDiv1").append("svg").attr("width", mapwidth).attr("height", height);
var svgMapElement2 = d3.select("#svgMapDiv2").append("svg").attr("width", mapwidth).attr("height", height);

//var projection = d3.geo.mercator().scale(16000*mapwidth/1100).center([-88.9, 20.8]);
var projection = d3.geo.mercator().scale(18*mapwidth).center([-87.5, 20.3]);
var path_projector = d3.geo.path().projection(projection);

var curDay=0;
var timeSeriesX=undefined;
var timeSeriesY=undefined;
var timeSeriesIndicatorBar=undefined;
var timeSeriesIndicatorText=undefined;
var xAxisSVGElement=undefined;

var unprocessedEvents1=[];
var unprocessedEvents2=[];
var muniMetaData={};
var updateFunctionTimer=undefined;
var lastDayLength=1;

function changeStartDay()        { startDay=parseInt($("#startingDayBox").val()); curDay=startDay; return startDay; }
function changeTimeStep()        { timeStep=parseInt($("#timeStepBox").val()); return timeStep; }
function changeDataSet()         { dataSet = document.getElementById('dataSetMenu').value; 
                                   getDataset1(dataSet+"_base.json"); 
                                   getDataset2(dataSet+"_vac.json"); 
                                   return dataSet; 
                                   }
function restartSimulation()     { changeStartDay();}

startDay = changeStartDay();

function drawTsPlot() {
    if (unprocessedEvents1.length == 0  || unprocessedEvents2.length==0) return;

    d3.select("#tsPlotDiv").selectAll("svg").remove()
    var tsPlotElement = d3.select("#tsPlotDiv").append("svg").attr("width", width).attr("height", tsPlotDivHeight);
    tsPlotElement.selectAll('g').remove()
    tsPlotElement.selectAll('path').remove()
    tsPlotElement.selectAll('text').remove()

    var data1 = calculateTimeSeriesData(unprocessedEvents1);
    var data2 = calculateTimeSeriesData(unprocessedEvents2);

    //http://www.janwillemtulp.com/2011/04/01/tutorial-line-chart-in-d3/
    //http://bl.ocks.org/mbostock/3883245
    //http://square.github.io/cubism/

    var margin = {top: 20, right: 0, bottom: 20, left: 80};
    timeSeriesX = d3.scale.linear().range([margin.left, width - margin.right]);
    timeSeriesY = d3.scale.linear().range([tsPlotDivHeight - margin.bottom, margin.top]);

    var xDomain = d3.extent(data1, function(d) { return d[0]; });
    //console.log(xDomain);
    timeSeriesX.domain(xDomain);
    var yDomain1 = d3.extent(data1, function(d) { return d[1]; });
    var yDomain2 = d3.extent(data2, function(d) { return d[1]; });
    //console.log(yDomain1);
    //console.log(yDomain2);
  
    var yDomain = [0,Math.max(yDomain1[1], yDomain2[1])];
    //yDomain[0] = 0; //-0.1 * yDomain[1]; // This makes it possible to draw a circle that's not cropped
    timeSeriesY.domain(yDomain);


    var xAxis = d3.svg.axis()
                  .scale(timeSeriesX)
                  .orient("bottom");
    var yDomainMagnitude = Math.floor(Math.log(yDomain[1])/Math.LN10);
    var yMaxTick = Math.floor(yDomain[1]/Math.pow(10,yDomainMagnitude)) * Math.pow(10,yDomainMagnitude);
    var yTicks = [0, Math.round(yMaxTick/2), yMaxTick]
    var yAxis = d3.svg.axis()
                  .scale(timeSeriesY)
                  .tickValues(yTicks)
                  .orient("left");


    var line = d3.svg.line()
        .x(function(d) { return timeSeriesX(d[0]); })
        .y(function(d) { return timeSeriesY(d[1]); });

    tsPlotElement
        .attr("width", width + margin.left + margin.right)
        .attr("height", tsPlotDivHeight + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var xAxisOffset = tsPlotDivHeight - 10;

     tsPlotElement.append("g")
        .attr("id", "xaxis")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + xAxisOffset + ")")
        .call(xAxis)
      .append("text")
        .attr("x", (margin.left + width)/2)
        .attr("dx", "-.71em")
        .attr("y", 40)
        //.style("text-anchor", "end")
        .text("Day");

    tsPlotElement.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + 50 + ",0)")
        .call(yAxis)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Incidence");

    tsPlotElement.append("path")
        .datum(data1)
        .attr("class", "line_base")
        .attr("d", line);

    tsPlotElement.append("path")
        .datum(data2)
        .attr("class", "line_vac")
        .attr("d", line);

    var drag = d3.behavior.drag()
        .on("dragstart", dragstarted)
        .on("drag", dragged)
        .on("dragend", dragended);
    // http://square.github.io/cubism/demo/

    datapoint = {'x':0, 'y':0};

    // vaccination indicator bar
    tsPlotElement.append("g")
        .attr("class", "bar")
        .selectAll("rect")
        .data([datapoint])
        .enter().append("rect")
        .attr("stroke","transparent")
        .attr("fill", "rgba(51,127,204,0.3)")
        .attr("x", timeSeriesX(5*365) )
        .attr("y", tsPlotDivHeight - margin.bottom )
        .attr("width", width - timeSeriesX(5*365))
        .attr("height", 9)
        .call(drag);

    var barWidth = 10;
    
    timeSeriesIndicatorBar = tsPlotElement.append("g")
        .attr("class", "bar")
        .selectAll("rect")
        .data([datapoint])
        .enter().append("rect")
        .attr("stroke","transparent")
        .attr("fill", "rgba(255,0,0,.5)")
        .attr("x", 0 )
        .attr("y", 0)
        .attr("width", barWidth)
        .attr("height", tsPlotDivHeight - margin.bottom + 5)
        .call(drag);

    timeSeriesIndicatorBarText=tsPlotElement.append("text")
        .attr("id","timeSeriesIndicatorBarText")
        .attr("x", 0)
        .attr("y", 5)
        .attr("dy", ".71em")
        .attr("fill", "red");

    updateTimeSeriesIndicator(startDay,"# of infections");
}

function drawMap(svgMapObject) {

    var graticule = d3.geo.graticule();
        graticule.precision(0.001);
        graticule.extent([[-89.5,20.5],[-88.5,21.5]]);

    d3.json("yuc_muni2.json", function(error, mx) {
      svgMapObject.selectAll("path")
        .data(topojson.object(mx, mx.objects.yucatan_municipalities).geometries)
        .enter().append("path")
        .attr("d", path_projector)
        .style("stroke", "#333")
        .style("stroke-width", ".2px")
        .attr("class", "myyuc")
        .style("fill", "white");

     var g = svgMapObject.append("g");
      
      g.selectAll("path")
        .data(topojson.object(mx, mx.objects.MEX_adm1).geometries)
        .enter().append("path")
        .attr("d", path_projector)
        .attr("fill", "transparent")
        .style("stroke", "#333");

       svgMapObject.append("path")
       .datum(graticule)
       .attr("class", "graticule")
       .attr("d", path_projector);

    });
}

function getDataset1(dataSetFilename) { 
  $.get("epi_data/".concat(dataSetFilename), function(json_string) { 
         console.log("Done downloading1...processing");
         unprocessedEvents1 = json_string;
         curDay=startDay;
         drawTsPlot();
  });
}

function getDataset2(dataSetFilename) { 
  $.get("epi_data/".concat(dataSetFilename), function(json_string) { 
         console.log("Done downloading2...processing");
         unprocessedEvents2 = json_string;
         curDay=startDay;
         drawTsPlot();
  });
}

function getMuniMetaData() { 
  $.get("muni_meta_data.json", function(json_string) { 
         console.log("Done downloading muni meta data processing");
         muniMetaData = json_string;  //already in json format
  });
}


function getColor(value) {
    var min=0;  var max=5;
    var s = (value-min)/(max-min);
    return d3.hsl(360.0, 100,0.5); //h,s,l red
}

function updatePolygonColors(timeStep, unprocessedEvents, svgMapObject, position) {
    //muniColorLookup
    var muni_prevalence={};
    var infection_ct=0;

    var _startDay = curDay;
    if(_startDay > unprocessedEvents.length) { _startDay=0; curDay=0; }
    var endDay = _startDay+timeStep;
    if(endDay > unprocessedEvents.length) endDay=unprocessedEvents.length;

    for(day=_startDay; day < endDay; day++ ) {
        var curDayPoints = unprocessedEvents[day];  //all muni pairs
        if (curDayPoints != null ) {
            // tally infections for each municipality
            for(muni in curDayPoints ) {
                if (muni == 'total') continue;
                infection_ct =curDayPoints[muni];

                if(muni in muni_prevalence) { 
                    muni_prevalence[muni] += infection_ct; 
                } else { 
                  muni_prevalence[muni] = infection_ct;
                }
            }
        }
    }

    //console.log(muni_prevalence);

    //color municipalities by incidence
    muni_objects=svgMapObject.selectAll(".myyuc")[0];        //array of arrays..first element 
    for(midx=0; midx<muni_objects.length; midx++ ) { //106
        if(midx in muni_prevalence) {
            yvalue=muni_prevalence[midx];
            populationSize = muniMetaData[midx]["pop"];
            if ( populationSize == undefined) populationSize=1;
            intensity_rescale = 1000.0/timeStep;
            yvalue = intensity_rescale * (yvalue/populationSize)*255;

            if (yvalue > 255) { yvalue = 255; }
            if (position == "left") {
                muni_objects[midx].style["fill"] = d3.rgb(255-yvalue*0.1, 255-yvalue*0.5, 255-yvalue*0.8);
            } else {
                muni_objects[midx].style["fill"] = d3.rgb(255-yvalue*0.8,255-yvalue*0.5,255-yvalue*0.2);
            }
        } else {
            //yvalue =Math.round(Math.random()*255);
            //muni_objects[midx].style["fill"] = d3.rgb(255-yvalue*0.8,255-yvalue*0.5,255-yvalue*0.2);
            muni_objects[midx].style["fill"] = "white";
        }
    }

    if (position == "right") {
        $("#curDayDiv").html("Current period: " + _startDay + "-" + endDay );
    }

}

function calculateTimeSeriesData(unprocessedEvents) { 
    var data = [];
    for(i=0; i < unprocessedEvents.length; i++ ) {   //number of days
        var curDayPoints = unprocessedEvents[i];     //array of [muni, ct] pairs
        var numInf=0;
        if (curDayPoints != null ) {    
              numInf = curDayPoints['total'];
        }
        data[i]=[i,numInf];
   }   
   return data;
}

function updateTimeSeriesIndicator(dayNumber,numInf) {
    timeSeriesIndicatorBar.attr("x", timeSeriesX(dayNumber));
    timeSeriesIndicatorBarText.attr("x", timeSeriesX(dayNumber)+20);
    timeSeriesIndicatorBarText.text(numInf);
}


function drawDailyEvents(dayNumber,unprocessedEvents) {
    var curDayPoints = unprocessedEvents[dayNumber];
    if (curDayPoints != null ) {
        var numInf=curDayPoints['total'];
        updateTimeSeriesIndicator(dayNumber, numInf);
    }
}

function update() { 
    if ((curDay-startDay) % timeStep == 0){
        updatePolygonColors(timeStep,unprocessedEvents1,svgMapElement1, "left");
        updatePolygonColors(timeStep,unprocessedEvents2,svgMapElement2, "right");
    }

    drawDailyEvents(curDay,unprocessedEvents1);

    curDay++;
    if (curDay > unprocessedEvents1.length) curDay = 0;
}

function stopSimulation() { 
  if(updateFunctionTimer != undefined) {
      clearInterval(updateFunctionTimer);
      updateFunctionTimer = undefined;
  }
}

function startSimulation() {
  if(updateFunctionTimer == undefined) {
      updateFunctionTimer = setInterval(update,1);
  }
}

function runSimulation() { 
    if(updateFunctionTimer == undefined) {
         startSimulation();
    } else {
        stopSimulation();
    }
}

function dragstarted(d) {
    stopSimulation();
    d3.event.sourceEvent.stopPropagation();
    d3.select(this).classed("dragging", true);
}

function dragged(d) {
    //console.log(d);
    var bbox = document.getElementById('xaxis').getBoundingClientRect();
    var estimateDay = ((d.x-100+5)/(bbox.width-5))*unprocessedEvents1.length;
    //var estimateDay = ((d.x-80+5)/(bbox.width-5))*1000;//*unprocessedEvents1.length;
    estimateDay = estimateDay < 0 ? 0 : estimateDay;
    $("#startingDayBox").val(Math.round(estimateDay));
    changeStartDay();
    update();
    var barPos = d3.event.x - 5;
    barPos = barPos < 75 ? 75 : 
             barPos > bbox.width + 70 ? bbox.width + 70 :
             barPos;
    //console.log(barPos);
    
    timeSeriesIndicatorBar.attr("x", d.x = barPos);
    timeSeriesIndicatorBarText.attr("x", d.x = barPos+20);
    
}

function dragended(d) {
    d3.select(this).classed("dragging", false);
//    startSimulation();
}

drawMap(svgMapElement1);
drawMap(svgMapElement2);
getMuniMetaData();

</script>

